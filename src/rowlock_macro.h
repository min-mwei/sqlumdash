/*
** SPDX-License-Identifier: MIT
**
** Copyright (c) 2018 Toshiba Corporation
**
*************************************************************************
** This file contains macros for row lock feature in order to reduce the
** amount of change for SQLite original source files.
*/
#ifndef SQLITE_OMIT_ROWLOCK

#ifdef SQLITE_OMIT_SHARED_CACHE
#error rowlock requires to enable shared cache
#endif


/* Macro for btree.h */
/* The flags parameter to sqlite3BtreeOpen */
#define BTREE_TRANS         16 /* This is a transaction DB */



/* Macro for btree.c */
#define ROWLOCK_TRANS_BTREE_COMMIT(p) \
  do { \
    int rc2 = sqlite3TransBtreeCommit(p); \
    if( rc2!=SQLITE_OK ){ \
      sqlite3BtreeLeave(p); \
      return rc2; \
    } \
  } while(0)

/* Macro for btree.c 
** Close rowlock savepoint and history in read transaction  
*/
#define ROWLOCK_TRANS_BTREE_CLEAN_READ_TRANS(p) \
  if ( p->inTrans==TRANS_READ ) { \
    BtreeTrans *pBtTrans = &p->btTrans; \
    if ( pBtTrans->pBtree!=NULL ) sqlite3rowlockSavepointClose(&pBtTrans->lockSavepoint); \
  }

#define ROWLOCK_TRANS_BTREE_CURSOR_CLOSE(pCur) \
  sqlite3TransBtreeCloseCursor(pCur)


/* Macro for alter.c and build.c */
#define ROWLOCK_TABLE_LOCK() \
  if( !isView && !IsVirtual(pTab) ) sqlite3TableLock(pParse, iDb, pTab->tnum, 2, pTab->zName)

#define ROWLOCK_TABLE_LOCK_FOR_ALTER() \
  if( !IsVirtual(pTab) ) sqlite3TableLock(pParse, iDb, pTab->tnum, 2, pTab->zName)

#define ROWLOCK_TABLE_LOCK_FOR_ALTER_IDB() \
  do { \
    int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema); \
    sqlite3TableLock(pParse, iDb, pTab->tnum, 2, pTab->zName); \
  } while(0)

/* Macro for build.c */
#define ROWLOCK_TABLE_LOCK_FOR_INDEX() \
  sqlite3TableLock(pParse, iDb, pIndex->pTable->tnum, 2, pIndex->pTable->zName)

/* Macro for trigger.c */
#define ROWLOCK_TABLE_LOCK_FOR_TRIGGER() \
  if( pTable && pTable->pSelect==0 ) \
    sqlite3TableLock(pParse, iDb, pTable->tnum, 2, pTable->zName)

/* Macro for vdbe.c */
#define ROWLOCK_SET_FORCE_COMMIT(p) \
  sqlite3SetForceCommit(p)

#define ROWLOCK_ENABLE_STMT_JOURNAL() \
  do { \
    /*
    ** There is possible that statement journal is not used for a
    ** write-transaction. So we force to use statement journal
    ** because statement rollback is required when record lock is
    ** occurred.
    */ \
    if( pOp->p2 && db->inVtabSavepoint==0 && p->usesStmtJournal==0 ){ \
      p->usesStmtJournal = 1; \
      p->stmtJournalEnabled = 1; \
    } \
  } while(0)

#define ROWLOCK_SAVEPOINT_CREATE() \
  do { \
    for(ii=0; ii<db->nDb; ii++){ \
      rc = sqlite3TransBtreeSavepointCreate(db->aDb[ii].pBt, db->nStatement+db->nSavepoint-1); \
      if( rc!=SQLITE_OK ) goto abort_due_to_error; \
    } \
  } while(0)

#define ROWLOCK_CACHED_ROWID_FLAG_SET() \
  sqlite3BtreeCachedRowidFlagSet(pC->uc.pCursor, 1)

#define ROWLOCK_CACHED_ROWID_SET() \
  sqlite3BtreeCachedRowidSet(pC->uc.pCursor, v)

#define ROWLOCK_CACHED_ROWID_SET_BY_OPEN_CURSOR() \
  do { \
    rc = sqlite3BtreeCachedRowidSetByOpenCursor(pCur->uc.pCursor); \
    if( rc ) goto abort_due_to_error; \
  } while(0)

#define ROWLOCK_CACHED_ROWID_UPDATE() \
  do { \
    if( sqlite3BtreeCachedRowidGet(pC->uc.pCursor) != 0 && \
        sqlite3BtreeCachedRowidGet(pC->uc.pCursor) <= x.nKey ){ \
      sqlite3BtreeCachedRowidSet(pC->uc.pCursor, x.nKey); \
    } \
  } while(0)

#define ROWLOCK_CACHED_ROWID_NEW_ROWID() \
  do { \
      v = sqlite3BtreeCachedRowidGet(pC->uc.pCursor); \
      if( v==MAX_ROWID ){ \
        pC->useRandomRowid = 1; \
      }else if( v!=0 ){ \
        v++; \
      }else{ \
        rc = sqlite3BtreeLastAll(pC->uc.pCursor, &res); \
        if( rc!=SQLITE_OK ){ \
          goto abort_due_to_error; \
        } \
        if( res ){ \
          v = 1; \
        }else{ \
          assert( sqlite3BtreeCursorIsValid(pC->uc.pCursor) ); \
          v = sqlite3BtreeIntegerKey(pC->uc.pCursor); \
          if( v==MAX_ROWID ){ \
            pC->useRandomRowid = 1; \
          }else{ \
            v++; \
          } \
        } \
      } \
  } while(0)

#define ROWLOCK_NOCONFLICT() \
  do { \
    /* For the OP_NoConflict opcode, checks whether someone has a lock of index which key is same. */ \
    if( pOp->opcode==OP_NoConflict ){ \
      rc = sqlite3BtreeNoConflict(pC->uc.pCursor, pIdxKey, p->minWriteFileFormat, &res); \
    }else{ \
      rc = sqlite3BtreeMovetoUnpackedAll(pC->uc.pCursor, pIdxKey, 0, 0, &res, pOp->opcode); \
    } \
  } while(0)

/* Macro for vdbeapi.c */
#define SQLITE_MAX_ROWID_RETRY 50
/* Retry the query execution if rowid generated by engine automatically 
** is corrupted.
*/
#define ROWLOCK_CACHED_ROWID_RETRY \
static int sqlite3StepOriginal(Vdbe *p); \
static int sqlite3Step(Vdbe *p){ \
  int rc = SQLITE_OK; \
  int cnt = 0; \
  while( (rc = sqlite3StepOriginal(p))==SQLITE_CORRUPT_ROWID \
         && cnt++ < SQLITE_MAX_ROWID_RETRY ){ \
    sqlite3_reset((sqlite3_stmt*)p); \
  } \
  return rc; \
}

/* Macro for vdbeaux.c */
#define ROWLOCK_VDBE_HALT(p) \
  do { \
    /* Release lock of tables for preventing COMMIT during statemet execution. */ \
    sqlite3BtreeUnlockStmtTableLock(p->db); \
    /* Close savepoints. OP_AutoCommit is not operated for force commit by DDL.
    ** So we do it here.
    */ \
    if( p->forceCommit ) sqlite3CloseSavepoints(p->db); \
    /* Revert usesStmtJournal flag if it was changed by this query execution. */ \
    if( p->stmtJournalEnabled) p->usesStmtJournal = 0; \
    p->stmtJournalEnabled = 0; \
  } while(0)

/* Macro for main.c */
#define ROWLOCK_INIT \
  do { \
    rc = rowlockInitialize(); \
    if( rc ) return rc; \
  } while(0)

#define ROWLOCK_MMAP_CONFIG \
    case SQLITE_CONFIG_MMAP_ROW_SIZE: { \
      sqlite3GlobalConfig.szMmapRowLock = va_arg(ap, sqlite3_int64); \
      break; \
    } \
    case SQLITE_CONFIG_MMAP_TABLE_SIZE: { \
      sqlite3GlobalConfig.szMmapTableLock = va_arg(ap, sqlite3_int64); \
      break; \
    }

/* Macro for global.c */
#define ROWLOCK_DEFAULT_MMAP_ROW_SIZE    (1024 * 1024)
#define ROWLOCK_DEFAULT_MMAP_TABLE_SIZE  (128 * 1024)
#define ROWLOCK_DEFAULT_PSM_INDEX_SIZE   (8 * 1024 * 1024)

/* Macro for pager.c */
#define ROWLOCK_WAIT_ON_EXCLUSIVE_LOCK() \
  if (locktype==EXCLUSIVE_LOCK) return SQLITE_OK


#define ROWLOCK_SKIP_GET_EXCLUSIVE_LOCK() \
  exFlag = 0

/* Macro for vacuum.c */
#define ROWLOCK_VACUM_LOCK(p) \
  rc = sqlite3rowlockExclusiveLockAllTables(p); \
  if( rc!=SQLITE_OK ) goto end_of_vacuum;

/* Macro for pragma.c */
/* Make "PRAGMA schema_version=N" force-commit mode. */
#define ROWLOCK_SCVER_OPECODE_ADD { OP_TableLock, 0, SCHEMA_ROOT, 1}

#define ROWLOCK_SCVER_OPECODE_MAKE() \
  do { \
      /* Move aOp[1] to aOp[2] */ \
      aOp[2].p1 = aOp[1].p1; \
      aOp[2].p2 = aOp[1].p2; \
      aOp[2].p3 = aOp[1].p3; \
      aOp[2].p5 = aOp[1].p5; \
      /* Set aOp[1]. This is for OP_TableLock. */ \
      aOp[1].p1 = iDb; \
      aOp[1].p2 = SCHEMA_ROOT; \
      aOp[1].p3 = 1; \
  } while(0)

/* Macro for backup.c */
#define ROWLOCK_BACKUP_LOCK() \
  do { \
    if( rc==SQLITE_OK ) rc = sqlite3BtreeBeginTransOriginal(p->pDest, 2, 0); \
    if( rc==SQLITE_OK ) rc = rowlockPagerExclusiveLock(pDestPager); \
  } while(0)

#endif